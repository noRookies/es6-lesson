<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="node_modules/babel-core/browser.js"></script>
    <script type="text/babel">
    /* {
           let a=10;
           var b=1;
           console.log("a===="+a);
       }
       console.log(b);
       for(let i=0;i<10;i++){
           console.log(i);
       }
       //console.log("a===="+i);
       var a = [];
       for (var i = 0; i < 10; i++) {
           a[i] = function () {
               console.log(i);
           };
       }
       a[6]();
       console.log("============");
       var a = [];
       for (let i = 0; i < 10; i++) {
           a[i] = function () {
               console.log(i);
           };
       }
       a[6](); // 10
       console.log("============");
       for (let i = 0; i < 3; i++) {
           let i = 'abc';
           console.log(i);
       }
       console.log("============");
       // var 的情况
       console.log(foo); // 输出undefined
       var foo = 2;

       // let 的情况
       console.log(bar); // 报错ReferenceError
       let bar = 2;*/
       console.log("============");

       var tmp = 123;
       if (true) {
           tmp = 'abc'; // ReferenceError
           console.log(tmp)
           let tmp;
       }
       console.log("============");
       if (true) {
           // TDZ开始
           tmp1 = 'abc'; // ReferenceError
           console.log(tmp1); // ReferenceError

           let tmp1; // TDZ结束
           console.log(tmp1); // undefined

           tmp1 = 123;
           console.log(tmp1); // 123

       }
    console.log("============");
    console.log(typeof x); // ReferenceError
    let x;
    console.log(typeof undeclared_variable) // "undefined"
    /* console.log("============");
    // 报错 不允许重复声明
   function c1() {
        let a = 10;
        var a = 1;
    }

    // 报错
    function c2() {
        let a = 10;
        let a = 1;
    }
    console.log("============");
    function func(arg) {
        let arg; // 报错
    }

    function func(arg) {
        {
            let arg; // 不报错
        }
    }*/
    console.log("============1");
    var tmp = new Date();

    function f() {
        console.log(tmp);
        if (false) {
            var tmp = "hello world";
        }
    }

    f(); // undefined

    console.log("============2");
    var s = 'hello';

    for (var i = 0; i < s.length; i++) {
        console.log(s[i]);
    }

    console.log(i); // 5
    console.log("============3");
    function f1() {
        let n = 5;
        if (true) {
            let n = 10;
        }
        console.log(n); // 5
    }
    f1();
    console.log("============4");
    {{{{
        let insane ="World Hello";
        {let insane = 'Hello World'}
        console.log(insane); // 报错
    }}}};
    console.log("============5");
    const PI = 3.1415;
    PI // 3.1415
        console.log(PI)

    const foo = 2.14;

    console.log("============6");
  /*  if (true) {
        const MAX = 5;
    }

    MAX // Uncaught ReferenceError: MAX is not defined
    console.log(MAX)*/

    console.log("============7");
    if (true) {
        console.log(MAX); // ReferenceError
        const MAX = 5;
    }
    console.log("============8");
    if (true) {

        console.log(MAX); // ReferenceError
        const MAX = 5;
    }
    console.log("============9")
    var message = "Hello!";
    let age = 25;

    // 以下两行都会报错
   // const message = "Goodbye!";
   // const age = 30;

    console.log("============10")
    const foo1 = {};
    foo1.prop = 123;

    foo1.prop
    // 123

   // foo = {}; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，
    // 这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，
    // 所以依然可以为其添加新属性。
    console.log("============11");
    const a = [];
    a.push('Hello'); // 可执行
    a.length = 0;    // 可执行
   // a = ['Dave'];    // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。
    console.log("============12");

    const foo2 = Object.freeze({name:1,age:2});
    console.log(foo2);

    // 常规模式时，下面一行不起作用；
    // 严格模式时，该行会报错
    //foo2.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。
    console.log("============13");
    var constantize = (obj) => {
        Object.freeze(obj);
        Object.keys(obj).forEach( (key, value) => {
            if ( typeof obj[key] === 'object' ) {
                constantize( obj[key] );
            }
        });
    };//除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。
    //ES5只有两种声明变量的方法：var命令和function命令。
    // ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。
    console.log("============14");
    window.g = 1;
    console.log(g); // 1

    g = 2;
    console.log(window.g) // 2
   //上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。
    console.log("============15");
    var h = 1;
    // 如果在Node的REPL环境，可以写成global.a
    // 或者采用通用方法，写成this.a
   console.log(window.h)  // 1

    let ba = 1;
    console.log(window.ba) // undefined


    </script>
</head>
<body>

</body>
</html>